## 1. Введение

### Типы данных:

+ **простые** — храним целиком, не подозреваем никаких операций с данными (сортировка, извлечение 5-ого символа и т.д –
  не оперируем частями этих данных)
    + примеры: фамилия, имя, целое число
+ **структурированные** — подозреваем операции: допустим хотим сгруппировать по региону), телефон (хотим сгруппировать
  по префиксу, хотим иметь быстродействие, допустим быстро извлечь города из адресов (парсинг по строчкам медленно)
    + примеры: адрес, email, url
+ **сущности**
    + примеры: студент, группа, предмет
+ **связи сущностей**
    + примеры студент состоит в ровно одной группе, у студента есть оценка
+ аналогия с ООП — **классы и объекты**

––––––––––––––––––

### Ограничения целостности:

+ **на отдельные значения** – допустим возраст >= 0, 0 <= вероятность <= 1
+ **на записи** – начало интервала меньше конца (допустим дата поступления <= дата окончания вуза)
+ **на наборы записей** – номера паспортов не повторяются
+ **на связи данных** – студент учится ровно в одной группе

––––––––––––––––––

### Типы баз данных:

+ **один файл / структурированный файл (с указанными типами)**
    + достоинства:
        + простота чтения
    + недостатки:
        + сложность поиска
        + сложность обработки
        + нет проверки целостности
        + сложность хранения разных типов (например даты: 6/9/2021 - 6 сентября / 9 июня?)
    + примеры: (dBase, Excel, Google spreadsheets)
+ **файловая система** (group/student/marks/subject) - файл == одна запись
    + достоинства:
        + структурирование данных
        + простота реализации
    + недостатки:
        + сложно извлекать требуемые данные
        + нет проверки целостности
        + большое кол-во файлов
    + примеры
+ **иерархическая база данных**
    + достоинства:
        + проверка целостности
        + эффективность реализации
        + последовательное расположение записей
    + недостатки:
        + нет отношения many-to-many
        + представление только древовидных структур
+ **сетевые базы данных**
+ ***реляционные базы данных*** - раньше хранили данные отдельно от связей (например в иерархической модели у студентов
  была табличка с оценками: Java, Math, C++, ...), но при этом в этой табличке не было информации про то, кем является
  студент. Э. Ф. Коддом в 1969 предложена идея хранить также связи.
    + Основной плюс в том, что за этой идеей стояла **математическая модель**, наш движок можем выполнить другой запрос,
      приводящий к такому же результату.
    + недостатки:
        + сложность реализации
        + сложность представления иерархических данных
        + сложность составления эффективных запросов
    + примеры: (Oracle Database, SQLite)

––––––––––––––––––

### Планировщик памяти — нужен для того чтобы

Application ->

Protocol Driver ->

СУБД -> разборщик запросов -> построитель плана исполнения (оптимизатор) / исполнитель запроса

Data storage

### Современные РСУБД

+ корпоративные
    + Oracle - высокая пропускная способность / невысокая скорость обновления / очень большая / широко распространена в
      бизнес-среде
+ свободные
    + MySQL (Sun / Oracle) - поддержка разных форматов хранения
    + PostgreSQL (Berkley University) - непосредственная поддержка связей, объектные расширения
    + Firebird (Borland, Firebird) – старая
+ встраиваемые
    + SQLite - In memory mode
    + Apache Derby  (Cloudscape, IBM, Apache) - pure Java / DB2 / Apache license
    + HyperSQLDB (hsqldb.org) - не поддерживает транзакции / in memory mode only / pure java / BSD license
    + MS Access

### SQL - structured query language

+ SQL-1986 - простые запросы / контроль доступа / курсоры – **data batch iterator**
+ SQL-1992 - новые типы соединений / динамические запросы
+ SQL-1999 - новая структура стандарта / необязательные требования / логический тип данных / Object Language Binding
+ SQL-2003 - XML / оконные функции / merge
+ SQL-2006 - XQuery
+ SQL-2011 - Темпоральные денные

### Commands:

+ **natural join** – сравнивает tupl'ы одинаковых столбцов из двух таблиц

## 2. Моделирование баз данных

### Типы моделей:

+ Физическая модель
    + **как** представлены данные в нашей базе
    + императивное описание
+ Концептуальная модель
    + **какие** данные существуют (url, password)
    + декларативное описание
+ Преобразование моделей

### Элементы физической модели:

+ ***таблицы*** — набор записей
    + строки (записи)
    + колонки (поля)
+ ***ссылки между таблицами***

+ ***ключи*** — набор **полей** идентифицирующих запись
    + **простой ключ** — одно поле (user_id)
    + **составной ключ** — несколько полей (series_no, passport_no)
    + **естественный (natural)** - ключи пришедшие из предметной области (серия и номер паспорта)
    + **суррогатные (surrogate)** - ключи сделанные нами для удобства (например id)
    + **основной (primary / first)** - используется в ссылках как основной ключ, если в таблице их есть несколько ключей
    + **дополнительный (secondary)** - все остальные ключи


+ ***ссылка*** - значения поля(ей) содержатся в ключе (другой) таблицы
    + **внешний ключ (foreign key)** – второе название ссылки (Students (GroupID) -> Groups (id, name))
    + **простая ссылка**
    + **составная ссылка**

+ ***графическое описание таблиц***
    + имя таблицы
    + нотация: \[имя колонки\] \[тип\] \[свойства\] -> (name varchar(100) "M" "PK")
    + **свойства**
        + M - mandatory (обязательное)
        + O - optional (необязательное)
        + PK - основной ключ
        + Kn - дополнительный ключ
    + **ссылки** (Students.GroupID) FK1 -> PK (Group.id)

### "Нотация сущность-связь"

+ ***сущность*** - \[имя атрибута\] \[домен\] \[свойства\]
    + **\[домен\]** – простой / сложный (выбираем физ. тип позже), примеры: name, phone:={code, number}

+ ***связь*** - \[имя\] \[тип\] \[связываемые сущности и роли\]

+ ***ассоциации*** - \[имя атрибута\] \[домен\] \[свойства\] – нет ключей
    + нагруженные – есть какие-то хранимые данные
    + многосторонние — несколько концов

### Ассоциация или связь?

У ассоциации нет identity

Правила:

+ простая и ненагруженная -> связь
+ можно ли идентифицировать –> сущность
+ иначе -> ассоциация

### Look-across, Chen-like

Зафиксировав все сущности получим ограничения на рассматриваемую (у каждого контракта один поручитель)

### Look-here, Meris-like

Ограничение на сущность (можно быть поручителем у ровно одного контракта)

### Слабая сущность – недостаточно атрибутов для идентификации

+ идентифицирующая связь получение дополнительных атрибутов
+ пример: Group(name) <-> University(name), если добавляем еще один университет то, идентифицирующая связь будет пара (
  группа, университет)

### Модель сущность связь -> физическая модель

+ постепенное преобразование
    + *связь many-to-many -> ассоциации* (по чену тип концов сохраняются / по мерис **меняются**)
    + *ассоциации -> **слабые** сущности*
    + *атрибуты -> колонки*
    + *концы -> связи*
        + обязательные – идентифицирующая связь
        + необязательные – обычная
    + *сущности -> таблицы*
        + простые атрибуты -> столбцы
        + составные атрибуты -> набор столбцов
        + домены -> типы
        + ключи -> ключи
        + идентифицирующая связь -> столбцы + ключи
    + *связь -> дополнительные атрибуты*
        + многие к одному — дополнительные со стороны "много"
        + один к одному – дополнительно со стороны обязательно

### Data definition language - часть SQL для описания данных

### Операторы для работы с таблицами:

+ **create table** - создание таблицы
+ **drop table** - удаление таблицы
+ **alter table** - изменение таблицы

## 3. Реляционная модель и Функциональные зависимости

## 4. Нормализация баз данных

+ Оптимизация схемы с целью:
    + преобразования ФЗ в ограничения ключей
    + упрощения изменения данных (не ключей)
    + ускорения изменения данных

+ Операции над отношениями:
    + проекция: `π_X(R) = {r ∩ X | r ∈ R} - проекция на атрибуты X`
        + может содержать меньше кортежей
        + "забывание" части атрибутов

    + соединение:
      `P1 ⋈ P2 = { r1 ∪ r2 | r1 ∈ P1, r2 ∈ P2 ∧ πY(r1) = πY(r2) }`
        + коммутативность: `P1 ⋈ P2 = P2 ⋈ P1`
        + ассоциативность: `P1 ⋈ (P2 ⋈ P3) = (P1 ⋈ P2) ⋈ P3`

    + декомпозиция: XYZ -> XY | YZ
        + не менее двух
        + сохранение всех атрибутов
        + хотим `d1, d2, .. dn = decompose(R) => natural join(d1, ..., dn) = R`
        + `R(A, B) = π_A(R) ⋈ π_B(R)`

    + Теорема Хита: `R(XYZ) и X -> Y => R = π_XY(R) ⋈ π_XZ(R), где X, Y и Z – множества атрибутов`
        + достаточное условие для корректности декомпозиции, то есть если у нас есть ФЗ X -> Y, то мы можем
          декомпозировать по X

### Нормальные формы

+ 1-ая нормальная форма (1НФ Дейт):
    + (не дублируем логически одни данные)
    + в отношении нет повторяющихся групп (допустим phone1, phone2, phone3), так же если придет phone4 – не знаем то с
      ним делать
    + все атрибуты атомарны – не можем записать phone как список phone1, phone2, phone3 (это ограничение запрещает
      массивы, множества и любые коллекции) – содержат ровно одно значение
    + у отношений есть ключ – запрет на одинаковые строки

+ 2-ая нормальная форма (2НФ):
    + 1НФ
    + Неключевые атрибуты функционально зависят от ключа в ***целом – то есть от всего ключа не может быть такого что
      атрибуты зависят от подмножества ключа*** **(не от части ключа)**
    + Неключевой атрибут – атрибут не входящий в ключ
    + Решение: **декомпозируем по части ключа**

+ 3-яя нормальная форма (3НФ):
    + 2НФ
    + Неключевые атрибуты непосредственно (не транзитивно) зависят от ключей – нет транзитивной зависимости от ключей
    + Решение: **Декомпозиция по последней ФЗ в цепочке**


+ Нормальная форма Бойса-Кодда (НФБК)
    + в каждой нетривиальной функциональной зависимости X -> Y, X является надключом
    + 3НФ и неперекрывающиесяся составные ключи => НФБК
    + Решение: **Декомпозиция по "нетривиальным" ФЗ**