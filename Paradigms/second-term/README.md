# Тесты к курсу «Парадигмы программирования»

[Условия домашних заданий](http://www.kgeorgiy.info/courses/paradigms/homeworks.html)


## Домашнее задание 11. Ассоциативные массивы на Prolog

Модификации
 * *Простая*
    * Код должен находиться в файле `sorted-list-map.pl`.
        * Запускать c аргументом `sorted`
 * *Сложная*
    * Код должен находиться в файле `tree-map.pl`.
        * Запускать c аргументом `hard` или `bonus`
 * *Replace*
    * Добавьте правило `map_replace(Map, Key, Value, Result)`,
        заменяющего значения ключа на указанное, если ключ присутствует.
 * *Size*
    * Добавьте правило `map_size(Map, Size)`, возвращающее размер дерева
 * *floorKey*
    * Добавьте правило `map_floorKey(Map, Key, FloorKey)`,
      вовзращающее максимальный ключ, меньший либо равный заданному.

## Домашнее задание 10. Комбинаторные парсеры
Модификации
 * *Базовая*
    * Код должен находиться в файле `parser.clj`.
        * Запускать c аргументом `easy` или `hard`
 * *Variables*. Дополнительно реализовать поддержку:
    * Переменных, состоящих из произвольного количества букв `XYZ` в любом регистре
        * Настоящее имя переменной определяется первой буквой ее имени
 * *PowLog*. Дополнительно реализовать поддержку:
    * Бинарных правоассоциативных операций максимального приоритета:
        * `Pow` (`**`) – возведения в степень:
            `4 ** 3 ** 2` равно `4 ** (3 ** 2)` равно 262144
        * `Log` (`//`) – взятия логарифма:
            `8 // 9 // 3` равно `8 // (9 // 3)` равно 3
 * *Bitwise*. Дополнительно реализовать поддержку:
    * Побитовых операций
        * `And` (`&`) – и: `5 & 6` равно 4
        * `Or` (`|`) - или: `5 & 6` равно 7
        * `Xor` (`^`) - исключающее: `5 ^ 6` примерно равно 1.66881E-308
        * для реализации операций используйте
            [doubleToLongBits](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double))
            и [longBitsToDouble](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long))
        * операции по увеличиению приоритета: `^`, `|`, `&`, `+` и `-`, `*` и `/`

## Домашнее задание 9. Объектные выражения на Clojure

Модификации
 * *Базовая*
    * Код должен находиться в файле `object.clj`.
        * Запускать c аргументом `easy` или `hard`
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Sinh` (`sinh`) – гиперболический синус, `(sinh 3)` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `(cosh 3)` немного меньше 10.
 * *SquareSqrt*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Square` (`square`) – возведение в квадрат, `(square 3)` равно 9;
        * `Sqrt` (`sqrt`) – извлечение квадратного корня из модуля аргумента, `(sqrt -9)` равно 3.


## Домашнее задание 8. Функциональные выражения на Clojure

Модификации
 * *Базовая*
    * Код должен находиться в файле `expression.clj`.
        * Запускать c аргументом `easy` или `hard`     
 * *Модификация SquareSqrt*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `square` (`square`) — возведение в квадрат, `(square 3)` равно 9;
        * `sqrt` (`sqrt`) — извлечение квадратного корня из модуля аргумента, `(sqrt -9)` равно 3.       
 * *Модификация MinMax*. Дополнительно реализовать поддержку:
    * операций:
        * `min` (`min`) — минимум, `(min 1 2 6)` равно 1;
        * `max` (`max`) — максимум, `(min 1 2 6)` равно 6;
        * Запускать c аргументом `easy` или `hard`      
 * *Модификация MedAvg*. Дополнительно реализовать поддержку:
    * операций:
        * `med` (`med`) — медиана, `(med 1 2 6)` равно 2;
        * `avg` (`max`) — среднее, `(min 1 2 6)` равно 3;
        * Запускать c аргументом `easy` или `hard`
        

## Домашнее задание 7. Линейная алгебра на Clojure

Модификация
 * *Shapeless*
    * Добавьте операции поэлементного сложения (`s+`),
        вычитания (`s-`) и умножения (`s*`) чисел и
        векторов любой (в том числе, переменной) формы.
        Например, `(s+ [[1 2] 3] [[4 5] 6])` должно быть равно `[[5 7] 9]`.
 * *Tensor*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного сложения (`t+`),
        вычитания (`t-`) и умножения (`t*`) тензоров.
        Например, `(s+ [[1 2] [3 4]] [[5 6] [7 8]])` должно быть равно `[[6 8] [10 12]]`.
 * *Broadcast*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * _Форма_ тензора – последовательность чисел
        (_s_<sub>1..n</sub>)=(_s_<sub>1</sub>, _s_<sub>2</sub>, …, _s<sub>n</sub>_), где
        _n_ – размерность тензора, а _s<sub>i</sub>_ – число элементов
        по _i_-ой оси.
      Например, форма тензора `[ [ [2 3 4] [5 6 7] ] ]`  равна (1, 2, 3),
      а форма `1` равна ().
    * Тензор формы (_s_<sub>1.._n_</sub>) может быть _распространен_ (broadcast)
      до тензора формы (_u_<sub>1.._m_</sub>), если (_s_<sub>i.._n_</sub>) является
      суффиксом (_u<sub>1..m</sub>_). Для этого, исходный тензор копируется
      по недостающим осям.
      Например, распространив тензор `[ [2] [3] ]` формы (2, 1) до
      формы (3, 2, 1) получим `[ [ [2] [3] ] [ [2] [3] ] [ [2] [3] ] ]`,
      а распространив `1` до формы (2, 3) получим `[ [1 1 1] [1 1 1] ]`.
    * Тензоры называются совместимыми, если один из них может быть распространен
      до формы другого.
      Например, тензоры формы (3, 2, 1) и (2, 1) совместимы, а
      (3, 2, 1) и (1, 2) – нет. Числа совместимы с тензорами любой формы.
    * Добавьте операции поэлементного сложения (`b+`),
      вычитания (`b-`) и умножения (`b*`) совместимых тензоров.
      Если формы тензоров не совпадают, то тензоры меньшей размерности
      должны быть предварительно распространены до тензоров большей размерности.
      Например, `(b+ 1 [ [10 20 30] [40 50 60] ] [100 200 300] )` должно
      быть равно `[ [111 221 331] [141 251 361] ]`.
      

## Домашнее задание 6. Обработка ошибок на JavaScript

1.  Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2.  Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3.  При выполнение задания следует обратить внимание на:
    *   Применение инкапсуляции.
    *   Выделение общего кода для бинарных операций.
    *   Обработку ошибок.
    *   Минимизацию необходимой памяти.

#### Модификации
*   _Базовая_
    *   Код должен находиться в файле `objectExpression.js`.
        *   Запускать c аргументом `easy` или `hard`
*   _PostfixSumexpSoftmax_. Дополнительно реализовать поддержку:
    *   выражений в постфиксной записи: `(2 3 +)` равно 5
    *   унарных операций:
        *   `Sumexp` (`sumexp`) — сумма экспонент, `(8 8 9 sumexp)` примерно равно 14065;
        *   `Softmax` (`softmax`) — softmax первого аргумента, `(1 2 3 softmax)` примерно 9;
*   _PrefixSumAvg_. Дополнительно реализовать поддержку:
    *   операций произвольного числа аргументов:
        *   `Sum` (`sum`) — сумма, `(sum 1 2 3)` равно 6;
        *   `Avg` (`avg`) — арифметическое среднее, `(avg 1 2 3)` равно 2;



## Домашнее задание 5. Объектные выражения на JavaScript


1.  Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с одной переменной.
    1.  Пример описания выражения `2x-3`:

                            let expr = new Subtract(
                                new Multiply(
                                    new Const(2),
                                    new Variable("x")
                                ),
                                new Const(3)
                            );

    2.  Метод `evaluate(x)` должен производить вычисления вида: При вычислении такого выражения вместо каждой переменной подставляется значение `x`, переданное в качестве параметра функции `evaluate` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
    3.  Метод `toString()` должен выдавать запись выражения в [обратной польской записи](http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, `expr.toString()` должен выдавать `2 x * 3 -`.
2.  **Усложненный вариант.**

    Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и

                        new Subtract(
                            new Add(
                                new Multiply(new Const(0), new Variable("x")),
                                new Multiply(new Const(2), new Const(1))
                            )
                            new Const(0)
                        )

    так же будут считаться правильным ответом).

    Функция `parse` должна выдавать разобранное объектное выражение.

3.  **Бонусный вариант.** Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,

    `parse("x x 2 - * 1 *").diff("x").simplify().toString()`

    должно возвращать «`x x 2 - +`».
4.  При выполнение задания следует обратить внимание на:
    *   Применение инкапсуляции.
    *   Выделение общего кода для операций.

#### Модификации
*   _Базовая_
    *   Код должен находиться в файле `objectExpression.js`.
        *   Запускать c аргументом `easy`, `hard` или `bonus`.
*   _ArcTan_. Дополнительно реализовать поддержку:
    *   функций:
        *   `ArcTan` (`atan`) — арктангенс, `1256 atan` примерно равно 1.57;
        *   `ArcTan2` (`atan2`) — арктангенс, `841 540 atan2` примерно равно 1;
*   _MinMax_. Дополнительно реализовать поддержку:
    *   функций:
        *   `Min3` (`min3`) — минимум из трех аргументов, `1 2 3 min` равно 1;
        *   `Max5` (`max5`) — максимум из пяти аргументов, `1 2 3 4 5 max` равно 5;
*   _SinhCosh_. Дополнительно реализовать поддержку:
    *   унарных функций:
        *   `Sinh` (`sinh`) — гиперболический синус, `3 sinh` немного больше 10;
        *   `Cosh` (`cosh`) — гиперболический косинус, `3 cosh` немного меньше 10;



## Домашнее задание 4. Функциональные выражения на JavaScript

1.  Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.
2.  Функции должны позволять производить вычисления вида:

                    let expr = subtract(
                        multiply(
                            cnst(2),
                            variable("x")
                        ),
                        cnst(3)
                    );
                    println(expr(5));
                

    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
3.  Тестовая программа должна вычислять выражение `x<sup>2</sup>−2x+1`, для `x` от 0 до 10.
4.  **Усложненный вариант.** Требуется написать функцию `parse`, осуществляющую разбор выражений, записанных в [обратной польской записи](http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, результатом
  
    `parse("x x 2 - * x * 1 +")(5)` должно быть число `76`.
5.  При выполнение задания следует обратить внимание на:
    *   Применение функций высшего порядка.
    *   Выделение общего кода для бинарных операций.

#### Модификации
*   _Базовая_
    *   Код должен находиться в файле `functionalExpression.js`.
        *   Запускать c аргументом `hard` или `easy`;
*   _PieAvgMed_. Дополнительно реализовать поддержку:
    *   переменных: `y`, `z`;
    *   констант:
        *   `pi` — π;
        *   `e` — основание натурального логарифма;
    *   операций:
        *   `avg5` — арифметическое среднее пяти аргументов, `1 2 3 4 5 avg5` равно 7.5;
        *   `med3` — медиана трех аргументов, `1 2 -10 med3` равно 1.
        *   Запускать c аргументом `hard`
*   _Variables_. Дополнительно реализовать поддержку:
    *   переменных: `y`, `z`;
        *   Запускать c аргументом `easy`
*   _OneIffAbs_. Дополнительно реализовать поддержку:
    *   переменных: `y`, `z`;
    *   констант:
        *   `one` — 1;
        *   `two` — 2;
    *   операций:
        *   `abs` — абсолютное значение, `-2 abs` равно 2;
        *   `iff` — условный выбор: если первый аргумент неотрицательный, вернуть второй аргумент, иначе вернуть первый третий аргумент.
            *   `iff one two 3` равно 2
            *   `iff -1 -2 -3` равно -3
            *   `iff 0 one two` равно 1;
        *   Запускать c аргументом `hard`
*   _IffAbs_. Дополнительно реализовать поддержку:
    *   переменных: `y`, `z`;
    *   операций:
        *   `abs` — абсолютное значение, `-2 abs` равно 2;
        *   `iff` — условный выбор: если первый аргумент неотрицательный, вернуть второй аргумент, иначе вернуть первый третий аргумент:
            *   `iff 1 2 3` равно 2
            *   `iff -1 -2 -3` равно -3
            *   `iff 0 1 2` равно 1;
        *   Запускать c аргументом `hard`
*   _OneTwo_. Дополнительно реализовать поддержку:
    *   переменных: `y`, `z`;
    *   констант:
        *   `one` — 1;
        *   `two` — 2;
        *   Запускать c аргументом `easy`



## Домашнее задание 3. Дженерик парсер

1\. Добавьте в программу вычисляющую выражения поддержку различных типов. * Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:
##### Опция Тип
`-i` `int`
`-d` `double`
`-bi` [BigInteger](http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html)

* Реализация не должна содержать [непроверяемых преобразований типов](http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.9).
* Реализация не должна использовать аннотацию [@SuppressWarnings](http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.5).

2\. При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.

#### Модификации
*   _Базовая_
    *   Класс `GenericTabulator` должен реализовывать интерфейс Tabulator и сроить трехмерную таблицу значений заданного выражения.
        *   `mode` — режим вычислений:
            *   `i` — вычисления в `int` с проверкой на переполнение;
            *   `d` — вычисления в `double` без проверки на переполнение;
            *   `bi` — вычисления в `BigInteger`.
        *   `expression` — выражение, для которого надо построить таблицу;
        *   `x1`, `x2` — минимальное и максимальное значения переменной `x` (включительно)
        *   `y1`, `y2`, `z1`, `z2` — аналогично для `y` и `z`.
        *   Результат: элемент `result[i][j][k]` должен содержать значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если значение не определено (например, по причине переполнения), то соответствующий элемент должен быть равен `null`.
*   _AsmUfb_
    *   Дополнительно реализовать унарные операции:
        *   `abs` — модуль числа, `abs -5` равно 5;
        *   `square` — возведение в квадрат, `square 5` равно 25.
    *   Дополнительно реализовать бинарную операцию (максимальный приоритет):
        *   `mod` — взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).
    *   Дополнительно реализовать поддержку режимов:
        *   `u` — вычисления в `int` без проверки на переполнение;
        *   `f` — вычисления в `float` без проверки на переполнение;
        *   `b` — вычисления в `byte` без проверки на переполнение.
*   _Ls_
    *   Дополнительно реализовать поддержку режимов:
        *   `l` — вычисления в `long` без проверки на переполнение;
        *   `s` — вычисления в `short` без проверки на переполнение.

*   _Ufb_
    *   Дополнительно реализовать поддержку режимов:
        *   `u` — вычисления в `int` без проверки на переполнение;
        *   `f` — вычисления в `float` без проверки на переполнение;
        *   `b` — вычисления в `byte` без проверки на переполнение.
    
    
    
## Домашнее задание 2. Md2Html парсер
  
1.  Разработайте конвертер из [Markdown](https://ru.wikipedia.org/wiki/Markdown)-разметки в [HTML](https://ru.wikipedia.org/wiki/HTML).
2.  Конвертер должен поддерживать следующие возможности:
    1.  Абзацы текста разделяются пустыми строками.
    2.  Элементы строчной разметки: выделение (<tt>*</tt> или <tt>_</tt>), сильное выделение (<tt>**</tt> или <tt>__</tt>), зачеркивание (<tt>--</tt>), код (<tt>`</tt>)
    3.  Заголовки (<tt>#</tt> * уровень заголовка)
3.  Конвертер должен называться <tt>Md2Html</tt> и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4.  Пример
*   Входной файл

        # Заголовок первого уровня

        ## Второго

        ### Третьего ## уровня

        #### Четвертого
        # Все еще четвертого

        Этот абзац текста,
        содержит две строки.

            # Может показаться, что это заголовок.
        Но нет, это абзац начинающийся с `#`.

        #И это не заголовок.

        ###### Заголовки могут быть многострочными
        (и с пропуском заголовков предыдущих уровней)

        Мы все любим *выделять* текст _разными_ способами.
        **Сильное выделение**, используется гораздо реже,
        но __почему бы и нет__?
        Немного --зачеркивания-- еще ни кому не вредило.
        Код представляется элементом `code`.

        Обратите внимание, как экранируются специальные
        HTML-символы, такие как `<`, `>` и `&`.

        Знаете ли вы, что в Markdown, одиночные * и _
        не означают выделение?
        Они так же могут быть заэкранированы
        при помощи обратного слэша: \*.

        Лишние пустые строки должны игнорироваться.

        Любите ли вы *вложеные __выделения__* так,
        как __--люблю--__ их я?
    
*   Выходной файл

        <h1>Заголовок первого уровня</h1>
        <h2>Второго</h2>
        <h3>Третьего ## уровня</h3>
        <h4>Четвертого
        # Все еще четвертого</h4>
        <p>Этот абзац текста,
        содержит две строки.</p>
        <p>    # Может показаться, что это заголовок.
        Но нет, это абзац начинающийся с <code>#</code>.</p>
        <p>#И это не заголовок.</p>
        <h6>Заголовки могут быть многострочными
        (и с пропуском заголовков предыдущих уровней)</h6>
        <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
        <strong>Сильное выделение</strong>, используется гораздо реже,
        но <strong>почему бы и нет</strong>?
        Немного <s>зачеркивания</s> еще ни кому не вредило.
        Код представляется элементом <code>code</code>.</p>
        <p>Обратите внимание, как экранируются специальные
        HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
        <p>Знаете ли вы, что в Markdown, одиночные * и _
        не означают выделение?
        Они так же могут быть заэкранированы
        при помощи обратного слэша: *.</p>
        <p>Лишние пустые строки должны игнорироваться.</p>
        <p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
        как <strong><s>люблю</s></strong> их я?</p>

    *   Реальная разметка

        # Заголовок первого уровня

        ## Второго

        ### Третьего ## уровня

        #### Четвертого # Все еще четвертого

        Этот абзац текста, содержит две строки.

        # Может показаться, что это заголовок. Но нет, это абзац начинающийся с `#`.

        #И это не заголовок.

        ###### Заголовки могут быть многострочными (и с пропуском заголовков предыдущих уровней)

        Мы все любим _выделять_ текст _разными_ способами. **Сильное выделение**, используется гораздо реже, но **почему бы и нет**? Немного <s>зачеркивания</s> еще ни кому не вредило. Код представляется элементом `code`.

        Обратите внимание, как экранируются специальные HTML-символы, такие как `<`, `>` и `&`.

        Знаете ли вы, что в Markdown, одиночные * и _ не означают выделение? Они так же могут быть заэкранированы при помощи обратного слэша: *.

        Лишние пустые строки должны игнорироваться.

        Любите ли вы _вложеные **выделения**_ так, как **<s>люблю</s>** их я?
        
#### Модификации
*   _Link_
    *   Добавьте поддержку `<span>[ссылок с _выделением_]([https://kgeorgiy.info](https://kgeorgiy.info))</span>`: `<span><a href='[https://kgeorgiy.info](https://kgeorgiy.info)'>ссылок с <em>выделением</em></a></span>`
    
*   _Underline_
    *   Добавьте поддержку `++подчеркивания++`: `<u>подчеркивания</u>`
    
*   _Image_
    *   Добавьте поддержку `<span>![картинок]([http://www.ifmo.ru/images/menu/small/p10.jpg](http://www.ifmo.ru/images/menu/small/p10.jpg))</span>`: `<span><img alt='картинок' src='[http://www.ifmo.ru/images/menu/small/p10.jpg](http://www.ifmo.ru/images/menu/small/p10.jpg)'></span>`
*   _Mark_
    *   Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`
    
*   _All_
    *   Добавьте поддержку всех вышеперечисленных модификаций


## Домашнее задание 1. Парсер

1.  Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
    *   ошибки разбора выражений;
    *   ошибки вычисления выражений.
2.  Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид: 
#                 
                    x       f
                    0       0
                    1       division by zero
                    2       32000000
                    3       121500000
                    4       341333333
                    5       overflow
                    6       overflow
                    7       overflow
                    8       overflow
                    9       overflow
                    10      overflow
                    
 Результат `division by zero` (`overflow`) означает, что в процессе вычисления произошло деление на ноль (переполнение).
3.  При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4.  Человеко-читаемые сообщения об ошибках должны выводится на консоль.
5.  Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

#### Модификации
*   _Базовая_
    *   Класс `ExpressionParser` должен реализовывать интерфейс Parser
    *   Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`, `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс TripleExpression
    *   Нельзя использовать типы `long` и `double`
    *   Нельзя использовать методы классов `Math` и `StrictMath`
*   _HighLow_
    *   Дополнительно реализовать унарные операции:
        *   `high` — значение, у которого оставлен только самый старший установленный бит `high -4` равно `Integer.MIN_VALUE`;
        *   `low` — значение, у которого оставлен только самый младший установленный бит `low 18` равно `2`.

