# Лабораторная работа №2. Ручное построение нисходящих синтаксических анализаторов

## [Методичка и варианты заданий](conditions.pdf)

Main классом является [Main](src/Main.java). 
На вход [Main](src/Main.java) получает входное и выходное имя файла,
после парсятся входные данные по заданной ниже грамматике и в  выходной файл выводится дерево на языке 
[DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language)).  
Входные данные могут быть введены как с консоли, так и в качестве аргументов программы. 


### Вариант 8. Описание заголовка функции в Python

Заголовок функции в Python. Заголовок начинается ключевым сло-вом “**def**”, далее идет имя функции, скобка, несколько имен аргументов через запятую, затем ‘**=**‘.


Используйте один терминал для всех имен переменных. Используйте один терминал для ключевых слов “**def**” и т. п. (не несколько ‘**d**’, ‘**e**’, ‘**f**с).
Пример:
 ```Python
def fib(n) = 
```

**Модификация**: Добавить поддержку декораторов (**@Decorator**)
Пример:
 ```Python
@Decorator
def add(a, b, c) = 
```

## Грамматика

В данной грамматике допускаются пробелы в любой части между токенами (в Python также).

| Нетерминал                           | Описание                                         |
|--------------------------------------|--------------------------------------------------|
| `START      -> DECORATOR DEFINITION` | Описание функции включая опциональный декоратор. |
| `DECORATOR  -> @word '\n'`           | Имя декоратора.                                  |
| `DECORATOR  -> ε`                    | Декоратор отсутствует.                           |
| `DEFINITION -> def FUN_NAME`         | Описание заголовка функции в Python.             |
| `FUN_NAME   -> word ( ARGS ) =`      | Описание списка аргументов в скобках.            |
| `ARGS       -> word , ARGS`          | Список аргументов через запятую.                 |
| `ARGS       -> word`                 | Последний аргумент.                              |
| `ARGS       -> ε`                    | В случае если функция не принимает аргументов.   |

Напомню, что для построения нисходящего парсера нужна [`LL(1)`-грамматика](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW).
Грамматика имеющая левую рекурсию или правое ветвления не является `LL(1)`. 
В этой грамматике из-за правила ARGS имеется правое ветвление - устраним его, используя алгоритм устранения [правого ветвления](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW#defLLK):

| Нетерминал                           | Описание                                             |
|--------------------------------------|------------------------------------------------------|
| `START      -> DECORATOR DEFINITION` | Описание функции включая опциональный декоратор.     |
| `DECORATOR  -> @word '\n'`           | Имя декоратора.                                      |
| `DECORATOR  -> ε`                    | Декоратор отсутствует.                               |
| `DEFINITION -> def FUN_NAME`         | Описание заголовка функции в Python.                 |
| `FUN_NAME   -> word ( ARGS ) =`      | Описание списка аргументов в скобках и знака assign. |
| `ARGS       -> word REST_ARGS`       | Описание списка аргументов через запятую.            |
| `ARGS       -> ε`                    | В случае если функция не принимает аргументов.       |
| `REST_ARGS  -> , ARGS`               | Продолжение списка аргументов.                       |
| `REST_ARGS  -> ε`                    | Конец объявления аргументов.                         |

## Терминалы

| Терминал  | Токен          |
|-----------|----------------|
| `@`       | AT             |
| `\n`      | NL             |
| `def`     | DEF            |
| `,`       | COMMA          |
| `(`       | OPENED_BRACKET |
| `)`       | CLOSED_BRACKET |
| `=`       | EQUALITY       |
| `$`       | END            | 
| `word`    | WORD           | 

[Lexer для получения токенов](src/lexer/Lexer.java)

## First and Follow

Построим мн-ва [First и Follow](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW#defLLK), используя [алгоритмы построения](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_FIRST_%D0%B8_FOLLOW):

| Нетерминал  | FIRST     | FOLLOW |
|-------------|-----------|--------|
| `START`     | `def`     | `$`    |
| `FUN_NAME`  | `word`    | `$`    |
| `ARGS`      | `word, ε` | `)`    |
| `REST_ARGS` | `word, ε` | `)`    |



Теперь, используя эти множества построим [Parser](src/parser/Parser.java)

Также приведу набор тестов(используется библиотека [JUnit](https://junit.org/junit5/)):
* [Тесты для Parser](src/tests/ParserTest.java)
