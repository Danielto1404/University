## Линзы

### FileSystem lenses

Разрешается использовать пакет `microlens`.

Задан тип данных, которым можно представить простое дерево файловой системы:
(record-syntax в суммах типов это все еще плохо)

```haskell
data FS
    = Dir
    { name     :: FilePath  -- название папки, не полный путь
    , contents :: [FS]
    }
    | File
    { name     :: FilePath  -- название файла, не полный путь
    }
```
Создайте функцию, которая «сканирует» заданную директорию и создаёт объект типа `FS` наподобие функции [`getDirectory'`](https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html#v:getDirectory-39-).

После этого создайте базовые линзы и призмы Вашего типа данных.

### Практика на линзы

> Блок практики не оценивается баллами. Он лишь предоставляет набор команд, которые полезно научиться реализовывать в одну строку при помощи линз, прежде чем приступать к дальнейшим заданиям. Все команды в списке очень простые, но если Вы не можете выполнить и их, значит, Вы не до конца разобрались с линзами, и выполнять дальнейшие задания ещё рано.

1. Список поддеревьев папки для `Dir`, иначе пустой список.
2. `Maybe` с именем директории, если `Dir`, или `Nothing` иначе.
3. Имя файла, если `File`, или пустую строку иначе.
4. Изменить имя корня дерева на `/`.
5. Добавить произвольный суффикс к имени корня дерева.
6. Получить имя самой первой папки в списке поддиректорий (`Nothing`, если такой нет).
7. Получить список имён только `File` из `Dir` (нерекурсивно).

### Обходы FS

Реализуйте следующие `Lens` или `Traversal`:

1. `cd`: перейти в поддиректорию с указанным именем.
2. `ls`: получить список имён содержимого директории.
3. `file`: получить имя конкретного `File`, если он существует.

В итоге должна быть возможность делать нечто похожее:

```haskell
myDir ^?  cd "A" . cd "B" . file "C"  -- Just "C" при существовании myDir/A/B/C
myDir ^.. cd "A" . cd "B" . ls        -- получить содержимое myDir/A/B/
```
